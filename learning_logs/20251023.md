# Login Process 진행

# REST API 호출
현재 상황에서 로그인을 성공한다고 하더라도 jwt를 세션 스토리지에 저장했을 뿐이고, 아직 getCars()의 결과값을 가져오지는 못합니다.

이 이유는 기본적으로 Login 컴포넌트에서 얻은 토큰을 가지로 frontend상에서 Carlist를 불러오지 못하고 있는 상황이기 때문입니다.

carapi.ts에 getCars() 호출을 할때 얻어온 jwt를 사용해야 하기 때문입니다.
근데 jwtToken 값이 생각해보면 .then()에 걸려있기 때문에 일종의 지역변수라고 생각하면됨


```tsx
import axios from "axios";
import { CarResponse, Car, CarEntity } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const token = sessionStorage.getItem('jwt');

    // 세션 스토리지 상에 'Bearer ' 가 포함되어있습니다. 근데 저희가 postman 상에서 요청을 날릴때 'Bearer ' 부분을 빼놓고 붙여넣기 했었던 것을 떠올려서 
    // 프론트 엔드 상에서 'Bearer' 를 제거하고, 그걸 기준으로 요청을 날렸습니다.
    const rawToken = token?.replace('Bearer ', '');

    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, {
        headers: { 'Authorization': `${rawToken}` }
    });

    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt')?.replace('Bearer ', '');
    const response = await axios.delete(link);
    return response.data
}

export const addCar = async (car: Car) : Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer ', '');
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, {
        headers: {
            'Content-Type': 'application/json',
            'Authorization': rawToken
        },
    });

    return response.data;
}

export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer ', '');
    const response = await axios.put(carEntity.url, carEntity.car, {
        headers: {
            'Content-Type': 'application/json',
            'Authorization': rawToken
        },
    });
    return response.data;
}
```
이상은 refactoring 전 부분입니다. 위에 말했던 것처럼 token을 세션 스토리지에서 불러오고, 여기서 Bearer 접두사를
제거하는 부분, 그리고 header 내에 'authorizetion' : token 부분이 중복되고 있다는 것을 확인할 수 있습니다.

이부분에서 알아야할 점은 Scope 개념이 되겠네요. 각 함수의 내부에서 token을 선언하고 Bear 접두사를 제거하고 있기 때문에 함수마다 선언 및 초기화를 하는 것 같습니다.

## 중복 코드 리펙토링

이상에서 고려할 점은 getAxiosConfig의 return 타입으로 사용된 AxiosRequestConfig입니다.

- AxiosRequestConfig: Axios 라이브러리에서 HTTP 요청을 만들때 사용되는 구성 객체 타입 정의에 해당합니다. 즉, Axios를 경유하여 요청을 보내기
위해 필요한 _모든 옵션_ 을 담는 일종의 interface에 해당합니다.

- 저희는 axios.post(), .get ...과 같은 방식으로 사용합니다. 이는 좀 더 가독성을 높이기 위한 방식으로 


## Authentication 실패시 오류 메시지를 토스트 메시지로 응용하겠습니다.

```tsx
<Snackbar 
  open={open}
  autoHideDuration={3000}
  onClose={() => setOpen(false)}
  message='ID 혹은 비밀번호가 틀렸습니다.🚓'
/>

```

라고 설정을 했다고 가정했을 때, 우리는 setOpen(true)를 호출하는 부분이 필요할 것 같습니다.
Login 컴포넌트 중 어떤 동작을 했을때 toast message가 출력되어야하며ㅑ, 그래서 setOpen(true)
코드를 삽입해야 하는 부분은 어딜까요 

